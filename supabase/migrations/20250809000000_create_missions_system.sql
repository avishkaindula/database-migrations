-- Create missions system tables
-- This migration creates the missions, submissions, bookmarks, and transaction tables

-- Create missions table
CREATE TABLE missions (
  id uuid DEFAULT gen_random_uuid() PRIMARY KEY,
  created_at timestamp with time zone DEFAULT timezone('utc'::text, now()) NOT NULL,
  updated_at timestamp with time zone DEFAULT timezone('utc'::text, now()) NOT NULL,
  created_by uuid REFERENCES auth.users ON DELETE CASCADE NOT NULL,
  organization_id uuid REFERENCES organizations(id) ON DELETE CASCADE NOT NULL,
  
  -- Core mission information
  title text NOT NULL CHECK (length(trim(title)) > 0),
  description text NOT NULL CHECK (length(trim(description)) > 0),
  
  -- Rewards
  points_awarded integer NOT NULL CHECK (points_awarded > 0),
  energy_awarded integer NOT NULL CHECK (energy_awarded > 0),
  
  -- Mission structure (stored as JSONB for flexibility)
  instructions jsonb NOT NULL DEFAULT '[]'::jsonb, -- Array of step objects with icon, title, description
  guidance_steps jsonb NOT NULL DEFAULT '[]'::jsonb, -- Array of guidance step objects with evidence requirements
  
  -- Media
  thumbnail_url text,
  
  -- Status and visibility
  status text NOT NULL DEFAULT 'draft' CHECK (status IN ('draft', 'published', 'archived')),
  is_featured boolean NOT NULL DEFAULT false,
  
  -- Constraints
  CONSTRAINT valid_instructions CHECK (jsonb_typeof(instructions) = 'array'),
  CONSTRAINT valid_guidance_steps CHECK (jsonb_typeof(guidance_steps) = 'array')
);

-- Create mission bookmarks table
CREATE TABLE mission_bookmarks (
  id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  created_at timestamp with time zone DEFAULT timezone('utc'::text, now()) NOT NULL,
  agent_id uuid REFERENCES agents(id) ON DELETE CASCADE NOT NULL,
  mission_id uuid REFERENCES missions(id) ON DELETE CASCADE NOT NULL,
  
  UNIQUE(agent_id, mission_id)
);

-- Create mission submissions table
CREATE TABLE mission_submissions (
  id uuid DEFAULT gen_random_uuid() PRIMARY KEY,
  created_at timestamp with time zone DEFAULT timezone('utc'::text, now()) NOT NULL,
  updated_at timestamp with time zone DEFAULT timezone('utc'::text, now()) NOT NULL,
  completed_at timestamp with time zone,
  
  -- References
  agent_id uuid REFERENCES agents(id) ON DELETE CASCADE NOT NULL,
  mission_id uuid REFERENCES missions(id) ON DELETE CASCADE NOT NULL,
  
  -- Submission status
  status text NOT NULL DEFAULT 'started' CHECK (status IN ('bookmarked', 'started', 'in_progress', 'completed', 'reviewed', 'rejected')),
  
  -- Evidence submissions for each guidance step
  -- Structure: { "step_1": [{"type": "photo", "data": "storage_id"}, {"type": "text", "data": "user input"}], "step_2": [...] }
  guidance_evidence jsonb NOT NULL DEFAULT '{}'::jsonb,
  
  -- Overall submission data (if any mission-level data is needed)
  additional_data jsonb DEFAULT '{}'::jsonb,
  
  -- Review information
  reviewed_by uuid REFERENCES auth.users,
  review_notes text,
  review_score integer CHECK (review_score >= 1 AND review_score <= 5),
  
  -- Ensure one active submission per agent per mission
  UNIQUE(agent_id, mission_id),
  
  -- Constraints
  CONSTRAINT valid_guidance_evidence CHECK (jsonb_typeof(guidance_evidence) = 'object'),
  CONSTRAINT valid_additional_data CHECK (jsonb_typeof(additional_data) = 'object')
);

-- Create point transactions table
CREATE TABLE point_transactions (
  id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  created_at timestamp with time zone DEFAULT timezone('utc'::text, now()) NOT NULL,
  
  -- References
  agent_id uuid REFERENCES agents(id) ON DELETE CASCADE NOT NULL,
  mission_id uuid REFERENCES missions(id) ON DELETE SET NULL,
  submission_id uuid REFERENCES mission_submissions(id) ON DELETE SET NULL,
  
  -- Transaction details
  transaction_type text NOT NULL CHECK (transaction_type IN ('earned', 'spent', 'bonus', 'penalty', 'refund')),
  points_amount integer NOT NULL,
  
  -- Description and metadata
  description text NOT NULL,
  metadata jsonb DEFAULT '{}'::jsonb,
  
  -- Running balance (for audit purposes)
  balance_after integer NOT NULL,
  
  -- Reference to what caused this transaction (reward redemption, etc.)
  reference_type text CHECK (reference_type IN ('mission_completion', 'reward_redemption', 'manual_adjustment', 'streak_bonus')),
  reference_id uuid
);

-- Create energy transactions table
CREATE TABLE energy_transactions (
  id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  created_at timestamp with time zone DEFAULT timezone('utc'::text, now()) NOT NULL,
  
  -- References
  agent_id uuid REFERENCES agents(id) ON DELETE CASCADE NOT NULL,
  mission_id uuid REFERENCES missions(id) ON DELETE SET NULL,
  submission_id uuid REFERENCES mission_submissions(id) ON DELETE SET NULL,
  
  -- Transaction details
  transaction_type text NOT NULL CHECK (transaction_type IN ('earned', 'bonus', 'penalty')),
  energy_amount integer NOT NULL,
  
  -- Description and metadata
  description text NOT NULL,
  metadata jsonb DEFAULT '{}'::jsonb,
  
  -- Running balance (for audit purposes)
  balance_after integer NOT NULL,
  
  -- Reference to what caused this transaction
  reference_type text CHECK (reference_type IN ('mission_completion', 'streak_bonus', 'manual_adjustment')),
  reference_id uuid
);

-- Create storage bucket for mission content
INSERT INTO storage.buckets (id, name)
VALUES ('mission-content', 'mission-content');

-- Create storage bucket for mission submissions
INSERT INTO storage.buckets (id, name)
VALUES ('mission-submissions', 'mission-submissions');

-- Create indexes for performance
CREATE INDEX idx_missions_organization_id ON missions(organization_id);
CREATE INDEX idx_missions_created_by ON missions(created_by);
CREATE INDEX idx_missions_status ON missions(status);
CREATE INDEX idx_missions_featured ON missions(is_featured) WHERE is_featured = true;

CREATE INDEX idx_mission_bookmarks_agent_id ON mission_bookmarks(agent_id);
CREATE INDEX idx_mission_bookmarks_mission_id ON mission_bookmarks(mission_id);

CREATE INDEX idx_mission_submissions_agent_id ON mission_submissions(agent_id);
CREATE INDEX idx_mission_submissions_mission_id ON mission_submissions(mission_id);
CREATE INDEX idx_mission_submissions_status ON mission_submissions(status);
CREATE INDEX idx_mission_submissions_completed_at ON mission_submissions(completed_at);

CREATE INDEX idx_point_transactions_agent_id ON point_transactions(agent_id);
CREATE INDEX idx_point_transactions_mission_id ON point_transactions(mission_id);
CREATE INDEX idx_point_transactions_created_at ON point_transactions(created_at);
CREATE INDEX idx_point_transactions_type ON point_transactions(transaction_type);

CREATE INDEX idx_energy_transactions_agent_id ON energy_transactions(agent_id);
CREATE INDEX idx_energy_transactions_mission_id ON energy_transactions(mission_id);
CREATE INDEX idx_energy_transactions_created_at ON energy_transactions(created_at);
CREATE INDEX idx_energy_transactions_type ON energy_transactions(transaction_type);

-- Create function to update agent balances based on transactions
CREATE OR REPLACE FUNCTION update_agent_balance()
RETURNS TRIGGER AS $$
BEGIN
  IF TG_TABLE_NAME = 'point_transactions' THEN
    UPDATE agents 
    SET points = NEW.balance_after
    WHERE id = NEW.agent_id;
  ELSIF TG_TABLE_NAME = 'energy_transactions' THEN
    UPDATE agents 
    SET energy = NEW.balance_after
    WHERE id = NEW.agent_id;
  END IF;
  
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Create triggers to automatically update agent balances
CREATE TRIGGER update_agent_points_balance
  AFTER INSERT ON point_transactions
  FOR EACH ROW
  EXECUTE FUNCTION update_agent_balance();

CREATE TRIGGER update_agent_energy_balance
  AFTER INSERT ON energy_transactions
  FOR EACH ROW
  EXECUTE FUNCTION update_agent_balance();

-- Create function to handle mission completion
CREATE OR REPLACE FUNCTION complete_mission_submission(
  p_submission_id uuid,
  p_reviewed_by uuid DEFAULT NULL,
  p_review_notes text DEFAULT NULL,
  p_review_score integer DEFAULT NULL
)
RETURNS void AS $$
DECLARE
  v_submission mission_submissions%ROWTYPE;
  v_mission missions%ROWTYPE;
  v_current_points integer;
  v_current_energy integer;
  v_new_points_balance integer;
  v_new_energy_balance integer;
BEGIN
  -- Get submission details
  SELECT * INTO v_submission
  FROM mission_submissions
  WHERE id = p_submission_id AND status = 'completed';
  
  IF NOT FOUND THEN
    RAISE EXCEPTION 'Submission not found or not in completed status';
  END IF;
  
  -- Check if already processed (avoid double processing)
  IF v_submission.status = 'reviewed' THEN
    RAISE EXCEPTION 'Submission already processed';
  END IF;
  
  -- Get mission details
  SELECT * INTO v_mission
  FROM missions
  WHERE id = v_submission.mission_id;
  
  -- Get current agent balances
  SELECT points, energy INTO v_current_points, v_current_energy
  FROM agents
  WHERE id = v_submission.agent_id;
  
  -- Calculate new balances
  v_new_points_balance := v_current_points + v_mission.points_awarded;
  v_new_energy_balance := v_current_energy + v_mission.energy_awarded;
  
  -- Create point transaction
  INSERT INTO point_transactions (
    agent_id, 
    mission_id, 
    submission_id,
    transaction_type,
    points_amount,
    description,
    balance_after,
    reference_type,
    reference_id
  ) VALUES (
    v_submission.agent_id,
    v_submission.mission_id,
    v_submission.id,
    'earned',
    v_mission.points_awarded,
    'Earned ' || v_mission.points_awarded || ' points for completing mission: ' || v_mission.title,
    v_new_points_balance,
    'mission_completion',
    v_submission.mission_id
  );
  
  -- Create energy transaction
  INSERT INTO energy_transactions (
    agent_id, 
    mission_id, 
    submission_id,
    transaction_type,
    energy_amount,
    description,
    balance_after,
    reference_type,
    reference_id
  ) VALUES (
    v_submission.agent_id,
    v_submission.mission_id,
    v_submission.id,
    'earned',
    v_mission.energy_awarded,
    'Earned ' || v_mission.energy_awarded || ' energy for completing mission: ' || v_mission.title,
    v_new_energy_balance,
    'mission_completion',
    v_submission.mission_id
  );
  
  -- Update submission status
  UPDATE mission_submissions
  SET 
    status = 'reviewed',
    reviewed_by = p_reviewed_by,
    review_notes = p_review_notes,
    review_score = p_review_score,
    updated_at = now()
  WHERE id = p_submission_id;
  
END;
$$ LANGUAGE plpgsql;

-- Create function to bookmark or start a mission
CREATE OR REPLACE FUNCTION bookmark_or_start_mission(
  p_agent_id uuid,
  p_mission_id uuid,
  p_action text -- 'bookmark' or 'start'
)
RETURNS uuid AS $$
DECLARE
  v_submission_id uuid;
  v_submission_status text;
BEGIN
  -- Validate action
  IF p_action NOT IN ('bookmark', 'start') THEN
    RAISE EXCEPTION 'Invalid action. Must be "bookmark" or "start"';
  END IF;
  
  -- Check if mission exists and is published
  IF NOT EXISTS (SELECT 1 FROM missions WHERE id = p_mission_id AND status = 'published') THEN
    RAISE EXCEPTION 'Mission not found or not published';
  END IF;
  
  -- Check if agent exists
  IF NOT EXISTS (SELECT 1 FROM agents WHERE id = p_agent_id) THEN
    RAISE EXCEPTION 'Agent not found';
  END IF;
  
  -- Set status based on action
  v_submission_status := CASE WHEN p_action = 'bookmark' THEN 'bookmarked' ELSE 'started' END;
  
  -- Insert or update submission
  INSERT INTO mission_submissions (agent_id, mission_id, status)
  VALUES (p_agent_id, p_mission_id, v_submission_status)
  ON CONFLICT (agent_id, mission_id) 
  DO UPDATE SET 
    status = CASE 
      WHEN mission_submissions.status = 'bookmarked' AND v_submission_status = 'started' THEN 'started'
      WHEN mission_submissions.status IN ('started', 'in_progress') AND v_submission_status = 'bookmarked' THEN mission_submissions.status
      ELSE v_submission_status
    END,
    updated_at = now()
  RETURNING id INTO v_submission_id;
  
  -- If bookmarking, also add to bookmarks table
  IF p_action = 'bookmark' THEN
    INSERT INTO mission_bookmarks (agent_id, mission_id)
    VALUES (p_agent_id, p_mission_id)
    ON CONFLICT (agent_id, mission_id) DO NOTHING;
  END IF;
  
  RETURN v_submission_id;
END;
$$ LANGUAGE plpgsql;

-- Set up storage policies for mission content
CREATE POLICY "Mission content is publicly viewable" ON storage.objects
  FOR SELECT USING (bucket_id = 'mission-content');

CREATE POLICY "Authenticated users can upload mission content" ON storage.objects
  FOR INSERT WITH CHECK (
    bucket_id = 'mission-content' 
    AND auth.role() = 'authenticated'
  );

CREATE POLICY "Authenticated users can update mission content" ON storage.objects
  FOR UPDATE USING (
    bucket_id = 'mission-content' 
    AND auth.role() = 'authenticated'
  );

-- Set up storage policies for mission submissions
CREATE POLICY "Users can view their own submissions" ON storage.objects
  FOR SELECT USING (
    bucket_id = 'mission-submissions'
    AND (storage.foldername(name))[1] = (SELECT auth.uid()::text)
  );

CREATE POLICY "Authenticated users can upload submissions" ON storage.objects
  FOR INSERT WITH CHECK (
    bucket_id = 'mission-submissions' 
    AND auth.role() = 'authenticated'
    AND (storage.foldername(name))[1] = (SELECT auth.uid()::text)
  );

CREATE POLICY "Authenticated users can view mission submissions" ON storage.objects
  FOR SELECT USING (
    bucket_id = 'mission-submissions'
    AND auth.role() = 'authenticated'
  );

-- Create function to automatically update updated_at timestamps
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
  NEW.updated_at = timezone('utc'::text, now());
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Create updated_at trigger for missions table
CREATE TRIGGER update_missions_updated_at
  BEFORE UPDATE ON missions
  FOR EACH ROW
  EXECUTE FUNCTION update_updated_at_column();

-- Create updated_at trigger for mission_submissions table
CREATE TRIGGER update_mission_submissions_updated_at
  BEFORE UPDATE ON mission_submissions
  FOR EACH ROW
  EXECUTE FUNCTION update_updated_at_column();
